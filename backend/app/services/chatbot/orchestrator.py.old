"""
Chatbot Orchestrator Service - State Machine Version
Strict funnel-based conversation flow for Hanco AI
Powered by Gemini AI with fallback
"""

import logging
import httpx
import json
import re
import uuid
from datetime import datetime, date
from typing import Dict, List, Optional, Any

from google.cloud import firestore

from app.core.config import settings
from app.core.security import validate_ai_input
from app.core.firebase import db, Collections

logger = logging.getLogger(__name__)

GEMINI_API_URL = (
    "https://generativelanguage.googleapis.com/v1/models/"
    "gemini-1.5-flash:generateContent"
)

# State Machine States
STATE_IDLE = "idle"
STATE_VEHICLE_TYPE = "vehicle_type"
STATE_SELECTION = "selection"
STATE_DATES = "dates"
STATE_PICKUP = "pickup"
STATE_DROPOFF = "dropoff"
STATE_INSURANCE = "insurance"
STATE_PAYMENT = "payment"
STATE_QUOTE = "quote"
STATE_CONFIRM = "confirm"
STATE_COMPLETED = "completed"

# State transitions
STATE_MACHINE = {
    STATE_IDLE: STATE_VEHICLE_TYPE,
    STATE_VEHICLE_TYPE: STATE_SELECTION,
    STATE_SELECTION: STATE_DATES,
    STATE_DATES: STATE_PICKUP,
    STATE_PICKUP: STATE_DROPOFF,
    STATE_DROPOFF: STATE_INSURANCE,
    STATE_INSURANCE: STATE_PAYMENT,
    STATE_PAYMENT: STATE_QUOTE,
    STATE_QUOTE: STATE_CONFIRM,
    STATE_CONFIRM: STATE_COMPLETED,
    STATE_COMPLETED: STATE_IDLE,
}

VEHICLE_TYPES = ["economy", "sedan", "suv", "luxury"]
PAYMENT_MODES = ["cash", "card"]
        return p.strip(), d.strip()
    if " to " in msg.lower():
        p, d = re.split(r"\bto\b", msg, maxsplit=1, flags=re.IGNORECASE)
        return p.strip(), d.strip()

    # Fallback: if user only gives one location, treat as pickup
    return msg, None


def _extract_city_from_location(loc: str) -> Optional[str]:
    """Try to guess the city from the pickup location string."""
    loc_lower = loc.lower()
    for c in ["riyadh", "jeddah", "dammam", "mecca", "medina", "taif"]:
        if c in loc_lower:
            return c
    return None


# ============================================================
# LLM-based intent detection (for general queries, not booking)
# ============================================================

async def detect_intent_and_extract(
    user_message: str,
    conversation_history: List[Dict],
    use_gemini: bool = True,
) -> Dict[str, Any]:
    """
    Detect user intent and extract structured data using Gemini or OpenAI.
    This is ONLY used when we are not already inside a booking flow.
    """
    try:
        context = "\n".join(
            [
                f"{'User' if msg['role'] == 'user' else 'Assistant'}: {msg['message']}"
                for msg in conversation_history[-5:]
            ]
        )

        system_prompt = f"""You are an AI assistant for Hanco AI, a car rental service in Saudi Arabia.

Task:
- Classify the user's message into one of: {', '.join(INTENTS)}.
- Extract information ONLY if user directly talks about dates, city, pricing, or cars.
- If user says they want to rent/book a car, set intent to "booking_help".

Conversation context:
{context}

User's latest message: {user_message}

Respond ONLY with JSON in this exact format:
{{
  "intent": "one of the intent types",
  "confidence": 0.0,
  "extracted": {{
    "city": "city name or null",
    "start_date": "YYYY-MM-DD or null",
    "end_date": "YYYY-MM-DD or null",
    "vehicle_category": "category or null",
    "vehicle_selection": "specific vehicle name or null"
  }},
  "reasoning": "brief explanation"
}}"""

        if use_gemini and getattr(settings, "GEMINI_API_KEY", None):
            return await _call_gemini(system_prompt, user_message)
        elif getattr(settings, "OPENAI_API_KEY", None):
            return await _call_openai(system_prompt, user_message)
        else:
            logger.warning("No AI API key configured, using rule-based intent detection")
            return _fallback_intent_detection(user_message)

    except Exception as e:
        logger.error(f"Intent detection error: {e}")
        return _fallback_intent_detection(user_message)


async def _call_gemini(prompt: str, user_message: str) -> Dict[str, Any]:
    """Call Gemini API with enhanced error handling and JSON parsing."""
    api_key = getattr(settings, "GEMINI_API_KEY", None)
    if not api_key:
        raise ValueError("GEMINI_API_KEY not configured")

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            resp = await client.post(
                f"{GEMINI_API_URL}?key={api_key}",
                json={
                    "contents": [{"parts": [{"text": prompt}]}],
                    "generationConfig": {
                        "temperature": 0.3,
                        "maxOutputTokens": 800,
                        "topP": 0.8,
                        "topK": 40,
                    },
                },
            )

        if resp.status_code != 200:
            logger.error(f"Gemini API error: {resp.status_code} - {resp.text}")
            raise ValueError(f"Gemini API returned status {resp.status_code}")

        data = resp.json()
        
        # Extract text from response
        if not data.get("candidates") or len(data["candidates"]) == 0:
            logger.warning("Gemini returned no candidates")
            raise ValueError("No response from Gemini")
            
        text = data["candidates"][0]["content"]["parts"][0]["text"]
        logger.info(f"Gemini raw response: {text[:200]}")

        # Try to extract JSON from the response
        # Remove markdown code blocks if present
        text = text.strip()
        if text.startswith("```json"):
            text = text[7:]
        if text.startswith("```"):
            text = text[3:]
        if text.endswith("```"):
            text = text[:-3]
        text = text.strip()

        # Find JSON object
        m = re.search(r"\{[\s\S]*\}", text)
        if not m:
            logger.warning(f"No JSON found in Gemini response: {text}")
            raise ValueError("No JSON in Gemini response")

        result = json.loads(m.group())
        
        # Validate structure
        if "intent" not in result:
            result["intent"] = "general_question"
        if "confidence" not in result:
            result["confidence"] = 0.7
        if "extracted" not in result:
            result["extracted"] = {}
        if "reasoning" not in result:
            result["reasoning"] = "Gemini classification"
            
        logger.info(f"Gemini detected intent: {result.get('intent')}, confidence: {result.get('confidence')}")
        return result
        
    except json.JSONDecodeError as e:
        logger.error(f"JSON decode error from Gemini: {e}")
        return _fallback_intent_detection(user_message)
    except Exception as e:
        logger.error(f"Gemini API call failed: {e}")
        return _fallback_intent_detection(user_message)


async def _call_openai(prompt: str, user_message: str) -> Dict[str, Any]:
    """Call OpenAI API as fallback."""
    api_key = getattr(settings, "OPENAI_API_KEY", None)
    if not api_key:
        raise ValueError("OPENAI_API_KEY not configured")

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            resp = await client.post(
                OPENAI_API_URL,
                headers={
                    "Authorization": f"Bearer {api_key}",
                    "Content-Type": "application/json",
                },
                json={
                    "model": "gpt-3.5-turbo",
                    "messages": [{"role": "system", "content": prompt}],
                    "temperature": 0.3,
                    "max_tokens": 500,
                },
            )

        if resp.status_code != 200:
            logger.error(f"OpenAI API error: {resp.status_code} - {resp.text}")
            raise ValueError("OpenAI error")

        data = resp.json()
        text = data["choices"][0]["message"]["content"]
        
        # Extract JSON
        m = re.search(r"\{[\s\S]*\}", text)
        if not m:
            raise ValueError("No JSON in OpenAI response")

        result = json.loads(m.group())
        logger.info(f"OpenAI detected intent: {result.get('intent')}")
        return result
        
    except Exception as e:
        logger.error(f"OpenAI API call failed: {e}")
        return _fallback_intent_detection(user_message)


def _fallback_intent_detection(user_message: str) -> Dict[str, Any]:
    """Rule-based fallback when AI APIs fail."""
    msg = user_message.lower()

    if any(x in msg for x in ["hello", "hi", "hey", "good morning", "good afternoon", "salam", "marhaba"]):
        intent = "greeting"
    elif any(x in msg for x in ["rent", "book", "reserve", "need a car", "want a car", "looking for"]):
        intent = "booking_help"
    elif any(x in msg for x in ["price", "cost", "how much", "rate", "payment"]):
        intent = "pricing_request"
    elif any(x in msg for x in ["compare", "competitor", "vs", "versus", "better deal"]):
        intent = "compare_competitors"
    elif any(x in msg for x in ["available", "show", "list", "vehicle", "car"]):
        intent = "vehicle_inquiry"
    else:
        intent = "general_question"

    return {
        "intent": intent,
        "confidence": 0.6,
        "extracted": _extract_basic_info(user_message),
        "reasoning": "Rule-based fallback",
    }


# ============================================================
# Pricing & competitor logic
# ============================================================

async def get_pricing_info(
    city: str,
    start_date: str,
    end_date: str,
    vehicle_category: str,
    firestore_client,
) -> Dict[str, Any]:
    """Get pricing information and competitor comparison."""
    try:
        start = datetime.strptime(start_date, "%Y-%m-%d").date()
        end = datetime.strptime(end_date, "%Y-%m-%d").date()

        vehicles_ref = firestore_client.collection("vehicles")
        # category in DB likely capitalized
        cat_map = {
            "economy": "Economy",
            "compact": "Compact",
            "sedan": "Sedan",
            "suv": "SUV",
            "luxury": "Luxury",
        }
        firestore_category = cat_map.get(vehicle_category.lower(), vehicle_category)

        vehicle_query = (
            vehicles_ref.where("category", "==", firestore_category)
            .where("city", "==", city.title())
            .where("availability_status", "==", "available")
            .limit(1)
            .stream()
        )

        vehicle_doc = None
        for doc in vehicle_query:
            vehicle_doc = doc.to_dict()
            break

        if not vehicle_doc:
            return {
                "error": f"No vehicles found in {vehicle_category} category in {city}",
                "recommended_price": None,
                "competitor_prices": [],
            }

        features = await build_pricing_features(
            vehicle_doc=vehicle_doc,
            start_date=start,
            end_date=end,
            city=city,
            firestore_client=firestore_client,
        )

        daily_price = predict_price(features)
        rental_days = (end - start).days or 1
        total_price = daily_price * rental_days

        competitor_ref = firestore_client.collection("competitor_prices")
        competitor_query = (
            competitor_ref.where("city", "==", city)
            .where("category", "==", vehicle_category)
            .limit(10)
            .stream()
        )

        competitors = []
        for doc in competitor_query:
            d = doc.to_dict()
            competitors.append(
                {
                    "provider": d.get("provider"),
                    "price": d.get("price"),
                    "vehicle_name": d.get("vehicle_name"),
                }
            )

        return {
            "recommended_price": {
                "daily_rate": round(float(daily_price), 2),
                "total_price": round(float(total_price), 2),
                "rental_days": rental_days,
            },
            "competitor_prices": competitors,
            "weather": {
                "avg_temp": features.get("avg_temp"),
                "rain": features.get("rain"),
                "wind": features.get("wind"),
            },
            "demand_index": features.get("demand_index", 0.5),
        }

    except Exception as e:
        logger.error(f"Error getting pricing info: {e}")
        return {"error": str(e), "recommended_price": None, "competitor_prices": []}


def _format_pricing_reply(
    vehicle_name: str,
    city: str,
    start_date: str,
    end_date: str,
    pricing_info: Dict[str, Any],
) -> str:
    """Format pricing information with competitor comparison."""
    if not pricing_info or not pricing_info.get("recommended_price"):
        return "I couldn't calculate the price right now. Please try again in a moment."

    p = pricing_info["recommended_price"]

    reply = f"**Pricing for {vehicle_name.title()}**\n\n"
    reply += f"üìç City: {city.title()}\n"
    reply += f"üìÖ {start_date} ‚Üí {end_date} ({p['rental_days']} days)\n"
    reply += f"üí∞ Our daily rate: {p['daily_rate']} SAR\n"
    reply += f"üí≥ Total rental price: {p['total_price']} SAR\n\n"

    weather = pricing_info.get("weather", {})
    if weather.get("avg_temp") is not None:
        reply += f"üå§ Avg temperature during your trip: {weather['avg_temp']}¬∞C\n"

    competitors = pricing_info.get("competitor_prices", [])
    if competitors:
        reply += "\n**Competitor daily rates:**\n"
        for c in competitors[:4]:
            reply += f"‚Ä¢ {c['provider'].title()}: {c['price']} SAR/day"
            if c.get("vehicle_name"):
                reply += f" ({c['vehicle_name']})"
            reply += "\n"

        avg_comp = sum(c["price"] for c in competitors) / len(competitors)
        if p["daily_rate"] < avg_comp:
            diff = avg_comp - p["daily_rate"]
            reply += f"\n‚úÖ You save about {diff:.2f} SAR/day with us on average.\n"
        else:
            diff = p["daily_rate"] - avg_comp
            reply += (
                f"\nüí° Our price is about {diff:.2f} SAR/day higher, "
                "but includes premium support and flexibility.\n"
            )

    reply += (
        "\nWould you like to continue to payment and confirm this booking? "
        "You can say **yes** to proceed or **no** to cancel."
    )

    return reply


# ============================================================
# Booking state-machine logic
# ============================================================

async def _fetch_vehicles_for_selection(
    firestore_client,
    category: str,
    city: Optional[str],
    limit: int = 5,
) -> List[Dict[str, Any]]:
    """Get available vehicles from Firestore."""
    vehicles_ref = firestore_client.collection("vehicles")
    query = vehicles_ref.where("availability_status", "==", "available")

    cat_map = {
        "economy": "Economy",
        "compact": "Compact",
        "sedan": "Sedan",
        "suv": "SUV",
        "luxury": "Luxury",
    }
    firestore_category = cat_map.get(category.lower(), category)
    query = query.where("category", "==", firestore_category)

    if city:
        query = query.where("city", "==", city.title())

    query = query.limit(limit)

    vehicles: List[Dict[str, Any]] = []
    for doc in query.stream():
        d = doc.to_dict()
        vehicles.append(
            {
                "id": doc.id,
                "name": d.get("name"),
                "category": d.get("category"),
                "city": d.get("city"),
                "price": d.get("current_price", d.get("base_daily_rate")),
            }
        )
    return vehicles


def _format_vehicle_list_message(
    vehicles: List[Dict[str, Any]],
    category: str,
    city: Optional[str],
) -> str:
    """Format vehicle list for display."""
    if not vehicles:
        city_part = f" in {city.title()}" if city else ""
        return (
            f"Right now I couldn't find available {category.title()} cars{city_part}. "
            "You can try another category or city."
        )

    emoji = {
        "Compact": "üöó",
        "Economy": "üöó",
        "Sedan": "üöô",
        "SUV": "üöê",
        "Luxury": "üíé",
    }
    reply = ""
    cat_title = vehicles[0].get("category", category.title())
    reply += f"{emoji.get(cat_title, 'üöó')} **{cat_title} options"
    if city:
        reply += f" in {city.title()}"
    reply += ":**\n\n"

    for idx, v in enumerate(vehicles, start=1):
        reply += (
            f"{idx}. {v['name']} ‚Äì {v['price']} SAR/day ({v.get('city', '')})\n"
        )

    reply += "\nPlease type the **car name or number** to select one."
    return reply


def _match_vehicle_selection(
    user_message: str, vehicles: List[Dict[str, Any]]
) -> Optional[Dict[str, Any]]:
    """Match user input to vehicle selection."""
    msg = user_message.lower().strip()

    # Allow numeric choice (1,2,3‚Ä¶)
    if msg.isdigit():
        idx = int(msg) - 1
        if 0 <= idx < len(vehicles):
            return vehicles[idx]

    # Match by substring name (FIXED: correct order)
    for v in vehicles:
        if v["name"] and msg in v["name"].lower():
            return v

    return None


async def _handle_booking_flow(
    booking_state: str,
    user_message: str,
    session_data: Dict[str, Any],
    firestore_client,
) -> (str, Dict[str, Any]):
    """
    Handle booking steps based on current booking_state.
    Returns (reply_message, updated_session_fields)
    """

    update: Dict[str, Any] = {}

    # 1) Vehicle type
    if booking_state == BOOKING_VEHICLE_TYPE:
        # Try to extract category
        info = _extract_basic_info(user_message)
        category = info.get("vehicle_category")

        if not category:
            # Try simple keyword match
            for cat in ["economy", "compact", "sedan", "suv", "luxury"]:
                if cat in user_message.lower():
                    category = cat
                    break

        if not category:
            return (
                "Please tell me what type of car you prefer:\n\n"
                "‚Ä¢ **Economy** - Budget-friendly compact cars\n"
                "‚Ä¢ **Compact** - Small and efficient\n"
                "‚Ä¢ **Sedan** - Comfortable mid-size cars\n"
                "‚Ä¢ **SUV** - Spacious for families\n"
                "‚Ä¢ **Luxury** - Premium experience\n\n"
                "Just type the category name (e.g., 'Sedan')",
                update,
            )

        city = session_data.get("city") or info.get("city")
        update["vehicle_category"] = category
        if city:
            update["city"] = city

        vehicles = await _fetch_vehicles_for_selection(
            firestore_client, category=category, city=city
        )
        update["booking_state"] = BOOKING_VEHICLE_SELECTION
        update["vehicle_options"] = vehicles  # stored for next step
        return _format_vehicle_list_message(vehicles, category, city), update

    # 2) Vehicle selection
    if booking_state == BOOKING_VEHICLE_SELECTION:
        vehicles = session_data.get("vehicle_options") or []
        selected = _match_vehicle_selection(user_message, vehicles)

        if not selected:
            msg = "I couldn't match that to one of the listed cars. "
            msg += "Please reply with the car **number** (like 1 or 2) or the car name."
            return msg, update

        update["selected_vehicle"] = selected
        update["booking_state"] = BOOKING_DATES
        return (
            f"Great choice! **{selected['name']}**.\n\n"
            "From **when to when** do you need the car? "
            "You can type dates in any format, for example:\n"
            "‚Ä¢ 2025-12-10 to 2025-12-15\n"
            "‚Ä¢ 10 Dec to 15 Dec\n"
            "‚Ä¢ 10/12/2025 - 15/12/2025\n"
            "‚Ä¢ from 10 December until 15 December",
            update,
        )

    # 3) Dates
    if booking_state == BOOKING_DATES:
        start_iso, end_iso = _parse_date_range(user_message)
        if not start_iso or not end_iso:
            return (
                "I couldn't clearly understand the dates. "
                "Please type them again, for example:\n"
                "‚Ä¢ `10 Dec to 15 Dec`\n"
                "‚Ä¢ `2025-12-10 to 2025-12-15`\n"
                "‚Ä¢ `from 10 December until 15 December`",
                update,
            )

        # CRITICAL: Save dates to update dict so they're in session for next step
        update["start_date"] = start_iso
        update["end_date"] = end_iso
        update["booking_state"] = BOOKING_LOCATIONS
        
        logger.info(f"Dates saved: {start_iso} to {end_iso}")
        
        return (
            f"Perfect! Got your dates: **{start_iso} to {end_iso}**.\n\n"
            "Now please tell me the **pickup and dropoff locations**.\n"
            "Example: `Riyadh Airport to Riyadh City`\n"
            "Or just: `Jeddah Airport` (if same for both)",
            update,
        )

    # 4) Locations
    if booking_state == BOOKING_LOCATIONS:
        pickup, dropoff = _extract_pickup_dropoff(user_message)
        if not pickup:
            return (
                "I couldn't read the pickup location. "
                "Please type it again, for example:\n"
                "‚Ä¢ `Riyadh Airport to Riyadh City`\n"
                "‚Ä¢ `Jeddah Airport`",
                update,
            )

        update["pickup_location"] = pickup
        update["dropoff_location"] = dropoff or pickup
        # Try to infer city from pickup, if not already known
        city = session_data.get("city") or _extract_city_from_location(pickup)
        if city:
            update["city"] = city

        # Get all required data from session
        category = session_data.get("vehicle_category")
        selected_vehicle = session_data.get("selected_vehicle", {})
        city = update.get("city") or session_data.get("city")
        start_date = session_data.get("start_date")
        end_date = session_data.get("end_date")

        # Log for debugging
        logger.info(f"Location step - city={city}, category={category}, start={start_date}, end={end_date}")

        pricing_info = None
        if city and start_date and end_date and category:
            try:
                logger.info(f"Calculating pricing: city={city}, category={category}, dates={start_date} to {end_date}")
                pricing_info = await get_pricing_info(
                    city=city,
                    start_date=start_date,
                    end_date=end_date,
                    vehicle_category=category,
                    firestore_client=firestore_client,
                )
                update["pricing_info"] = pricing_info
                logger.info(f"Pricing calculated successfully")
            except Exception as e:
                logger.error(f"Error calculating pricing: {e}", exc_info=True)
                # Set fallback pricing structure instead of leaving as None
                pricing_info = {
                    "recommended_price": {
                        "daily_rate": "TBD",
                        "total_price": "TBD",
                        "rental_days": 0
                    },
                    "competitor_prices": [],
                    "error": str(e)
                }
                update["pricing_info"] = pricing_info
        else:
            logger.warning(f"Missing data for pricing: city={city}, start={start_date}, end={end_date}, category={category}")

        update["booking_state"] = BOOKING_CONFIRMATION

        if pricing_info and pricing_info.get("recommended_price"):
            reply = _format_pricing_reply(
                vehicle_name=selected_vehicle.get("name", category),
                city=city or "your city",
                start_date=start_date,
                end_date=end_date,
                pricing_info=pricing_info,
            )
            return reply, update

        # Fallback message if pricing failed
        return (
            f"‚úÖ Pickup: **{pickup}**\n"
            f"‚úÖ Dropoff: **{dropoff or pickup}**\n\n"
            "I'm ready to create your booking! "
            "Please say **yes** to confirm or **no** to cancel.",
            update,
        )

    # 5) Confirmation
    if booking_state == BOOKING_CONFIRMATION:
        msg = user_message.lower()
        if any(x in msg for x in ["yes", "confirm", "ok", "sure", "yup", "proceed", "continue"]):
            # Create a booking document (pending payment)
            bookings_ref = firestore_client.collection("bookings")
            booking_data = {
                "created_at": firestore.SERVER_TIMESTAMP,
                "status": "pending_payment",
                "session_id": session_data.get("session_id"),
                "user_id": session_data.get("user_id"),
                "city": session_data.get("city"),
                "vehicle_category": session_data.get("vehicle_category"),
                "selected_vehicle": session_data.get("selected_vehicle"),
                "start_date": session_data.get("start_date"),
                "end_date": session_data.get("end_date"),
                "pickup_location": session_data.get("pickup_location"),
                "dropoff_location": session_data.get("dropoff_location"),
                "pricing_info": session_data.get("pricing_info"),
            }
            booking_doc = bookings_ref.document()
            booking_id = booking_doc.id
            booking_data["booking_id"] = booking_id
            booking_doc.set(booking_data)

            update["booking_state"] = BOOKING_COMPLETED
            update["booking_id"] = booking_id

            payment_link = f"/payment?booking_id={booking_id}"
            
            # Get pricing for summary - handle None safely
            pricing_info = session_data.get("pricing_info") or {}
            recommended = pricing_info.get("recommended_price") or {}
            total = recommended.get("total_price", "TBD")
            
            reply = (
                f"üéâ **Booking Confirmed!**\n\n"
                f"Booking ID: **{booking_id}**\n"
                f"Vehicle: **{session_data.get('selected_vehicle', {}).get('name', 'N/A')}**\n"
                f"Dates: **{session_data.get('start_date')} to {session_data.get('end_date')}**\n"
                f"Pickup: **{session_data.get('pickup_location')}**\n"
                f"Total: **{total} SAR**\n\n"
                f"üîó [Proceed to Payment]({payment_link})\n\n"
                "Once payment is successful, your booking will be confirmed and you'll receive a confirmation email!"
            )
            return reply, update

        if any(x in msg for x in ["no", "cancel", "stop", "abort"]):
            update["booking_state"] = BOOKING_IDLE
            return (
                "‚ùå No problem, I have cancelled this booking flow. "
                "If you want to start again, just say **I want to rent a car**.",
                update,
            )

        return (
            "Please say **yes** to continue with payment or **no** to cancel the booking.",
            update,
        )

    # If somehow reached here with invalid state
    update["booking_state"] = BOOKING_IDLE
    return (
        "I got a bit confused about where we were in the booking. "
        "Let's start again ‚Äî tell me **I want to rent a car**.",
        update,
    )


# ============================================================
# Main message handler
# ============================================================

async def handle_message(
    session_id: str,
    user_message: str,
    user: Dict,
    firestore_client,
) -> Dict[str, Any]:
    """
    Main orchestrator for handling chat messages.
    Orchestration logic:
      1) Validate AI input (prevent prompt injection)
      2) Load session (including booking_state)
      3) If we are mid-booking ‚Üí use booking state machine
      4) Else ‚Üí use intent detection (Gemini) for general queries
    """
    try:
        # AI SECURITY: Validate and sanitize user input before processing
        try:
            validate_ai_input(user_message)
        except ValueError as e:
            logger.warning(f"Invalid AI input from session {session_id}: {str(e)}")
            return {
                "reply": "I'm sorry, your message contains invalid content. Please rephrase your request.",
                "intent": "validation_error",
                "extracted": {},
                "session_id": session_id,
            }
        
        logger.info(
            f"Processing message for session {session_id}: {user_message[:80]!r}"
        )

        messages_ref = firestore_client.collection("chat_messages")
        session_ref = firestore_client.collection("chat_sessions").document(
            session_id
        )

        # Load session data (if exists)
        session_doc = session_ref.get()
        session_data: Dict[str, Any] = session_doc.to_dict() if session_doc.exists else {}
        booking_state = session_data.get("booking_state", BOOKING_IDLE)

        # Load conversation history for LLM context (best effort)
        conversation_history: List[Dict[str, Any]] = []
        try:
            history_docs = (
                messages_ref.where("session_id", "==", session_id)
                .order_by("timestamp")
                .limit(20)
                .stream()
            )
            for doc in history_docs:
                d = doc.to_dict()
                conversation_history.append(
                    {
                        "role": d.get("role"),
                        "message": d.get("message"),
                        "timestamp": d.get("timestamp"),
                    }
                )
        except Exception as e:
            logger.warning(f"Could not load conversation history: {e}")

        # -------------------------------------------
        # 1) If we already are inside a booking flow,
        #    completely ignore normal intent detection
        # -------------------------------------------
        if booking_state != BOOKING_IDLE and booking_state != BOOKING_COMPLETED:
            logger.info(f"Continuing booking flow in state: {booking_state}")
            reply, updated_fields = await _handle_booking_flow(
                booking_state, user_message, session_data, firestore_client
            )
            # merge session data
            updated_fields.update(
                {
                    "session_id": session_id,
                    "user_id": user.get("uid") if user else None,
                    "last_activity": firestore.SERVER_TIMESTAMP,
                }
            )
            session_ref.set(updated_fields, merge=True)
            booking_state = updated_fields.get("booking_state", booking_state)
            extracted = {}  # not used in this path
            intent = "booking_flow"

        else:
            # -------------------------------------------
            # 2) No active booking: use intent detection
            # -------------------------------------------
            logger.info("No active booking - using intent detection")
            intent_result = await detect_intent_and_extract(
                user_message, conversation_history
            )
            intent = intent_result.get("intent", "general_question")
            extracted = intent_result.get("extracted", {}) or {}
            logger.info(f"Detected intent={intent}, extracted={extracted}")

            # --- Greeting ---
            if intent == "greeting":
                reply = (
                    "Hello! üëã I'm **Hanco AI Assistant**.\n\n"
                    "I can help you:\n"
                    "‚Ä¢ Rent a car in Saudi Arabia üöó\n"
                    "‚Ä¢ Compare prices with competitors üí∞\n"
                    "‚Ä¢ Guide you through booking üìã\n\n"
                    "To start, just say: **I want to rent a car**"
                )

            # --- Booking start ---
            elif intent == "booking_help" or any(
                x in user_message.lower() for x in ["rent", "book", "reserve", "need a car", "want a car"]
            ):
                # Start booking flow
                booking_state = BOOKING_VEHICLE_TYPE
                city = extracted.get("city")
                session_ref.set(
                    {
                        "session_id": session_id,
                        "user_id": user.get("uid") if user else None,
                        "booking_state": booking_state,
                        "city": city,
                        "last_activity": firestore.SERVER_TIMESTAMP,
                    },
                    merge=True,
                )
                reply = (
                    "Nice! Let's get you a car. üöó\n\n"
                    "First, what type of car do you prefer?\n\n"
                    "‚Ä¢ **Economy** - Budget-friendly\n"
                    "‚Ä¢ **Compact** - Small and efficient\n"
                    "‚Ä¢ **Sedan** - Comfortable mid-size\n"
                    "‚Ä¢ **SUV** - Spacious for families\n"
                    "‚Ä¢ **Luxury** - Premium experience\n\n"
                    "Just reply with the type, like **Sedan**"
                )
                extracted = {"city": city}

            # --- General pricing question (not full flow) ---
            elif intent in ["pricing_request", "compare_competitors"]:
                info = _extract_basic_info(user_message)
                city = extracted.get("city") or info.get("city")
                category = extracted.get("vehicle_category") or info.get(
                    "vehicle_category"
                )
                start_iso, end_iso = _parse_date_range(user_message)
                if not (city and category and start_iso and end_iso):
                    reply = (
                        "To give you an exact price I need:\n\n"
                        "‚Ä¢ **City** (Riyadh, Jeddah, Dammam, Mecca, Medina, Taif)\n"
                        "‚Ä¢ **Vehicle type** (Economy, Compact, Sedan, SUV, Luxury)\n"
                        "‚Ä¢ **Dates** (e.g., `2025-12-10 to 2025-12-15`)\n\n"
                        "You can type it like:\n"
                        "`I need a Sedan in Riyadh from 2025-12-10 to 2025-12-15`"
                    )
                else:
                    pricing_info = await get_pricing_info(
                        city=city,
                        start_date=start_iso,
                        end_date=end_iso,
                        vehicle_category=category,
                        firestore_client=firestore_client,
                    )
                    reply = _format_pricing_reply(
                        vehicle_name=category,
                        city=city,
                        start_date=start_iso,
                        end_date=end_iso,
                        pricing_info=pricing_info,
                    )

            # --- Vehicle inquiry ---
            elif intent == "vehicle_inquiry":
                info = _extract_basic_info(user_message)
                city = extracted.get("city") or info.get("city")
                category = extracted.get("vehicle_category") or info.get("vehicle_category")
                
                if category:
                    vehicles = await _fetch_vehicles_for_selection(
                        firestore_client, category=category, city=city, limit=5
                    )
                    reply = _format_vehicle_list_message(vehicles, category, city)
                    reply += "\n\nWould you like to book one? Say **I want to rent a car** to start!"
                else:
                    reply = (
                        "I can show you available vehicles!\n\n"
                        "Which category are you interested in?\n"
                        "‚Ä¢ Economy\n‚Ä¢ Compact\n‚Ä¢ Sedan\n‚Ä¢ SUV\n‚Ä¢ Luxury"
                    )

            # --- FAQ / general question ---
            elif intent == "faq":
                reply = (
                    "I can help you with:\n\n"
                    "‚Ä¢ **Renting a car** (full booking flow)\n"
                    "‚Ä¢ **Checking prices** and discounts\n"
                    "‚Ä¢ **Comparing prices** with competitors\n"
                    "‚Ä¢ **Viewing available vehicles** in each city\n\n"
                    "Tell me what you want, for example:\n"
                    "*I want to rent a car in Riyadh*"
                )

            else:
                # Very generic default
                reply = (
                    "I'm here to help you with car rentals in Saudi Arabia! üá∏üá¶\n\n"
                    "You can say things like:\n"
                    "‚Ä¢ *I want to rent a car*\n"
                    "‚Ä¢ *Show me available SUVs in Riyadh*\n"
                    "‚Ä¢ *Compare your prices with competitors for a sedan in Jeddah*\n\n"
                    "How can I assist you today?"
                )

            # Update session "last seen"
            session_ref.set(
                {
                    "session_id": session_id,
                    "user_id": user.get("uid") if user else None,
                    "booking_state": booking_state,
                    "last_activity": firestore.SERVER_TIMESTAMP,
                    "last_message": user_message[:100],
                },
                merge=True,
            )

        # -------------------------------------------
        # Save chat messages
        # -------------------------------------------
        user_msg_ref = messages_ref.document()
        user_msg_ref.set(
            {
                "session_id": session_id,
                "role": "user",
                "message": user_message,
                "timestamp": firestore.SERVER_TIMESTAMP,
                "user_id": user.get("uid") if user else None,
            }
        )

        assistant_msg_ref = messages_ref.document()
        assistant_msg_ref.set(
            {
                "session_id": session_id,
                "role": "assistant",
                "message": reply,
                "intent": intent,
                "extracted": extracted,
                "timestamp": firestore.SERVER_TIMESTAMP,
            }
        )

        # Increase message count
        session_ref.set(
            {
                "message_count": firestore.Increment(2),
            },
            merge=True,
        )

        logger.info(f"‚úÖ Message processed successfully for session {session_id}")

        return {
            "reply": reply,
            "intent": intent,
            "extracted": extracted,
            "session_id": session_id,
            "booking_state": booking_state,
        }

    except Exception as e:
        safe_log_error("Error handling chatbot message", e)
        return {
            "reply": "I'm sorry, something went wrong while processing your request. "
                     "Please try again in a moment.",
            "intent": "error",
            "extracted": {},
            "session_id": session_id,
            "error": str(e),
        }
